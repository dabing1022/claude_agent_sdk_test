# DeepWiki Q&A with Code Context for Repository: refly-ai/refly
## Q1
refly使用的沙箱代码技术是啥
## Refly沙箱代码技术架构
这个代码图展示了Refly使用的沙箱技术架构，主要基于Scalebox SDK实现云端代码执行。涵盖了从[1a]用户请求接收到[5d]结果上传的完整流程，包括[2a]沙箱池管理、[3a]SDK集成和[6c]安全限制等关键组件。
### 1. Scalebox沙箱执行流程
从用户请求到代码在Scalebox沙箱中执行的完整流程
### 1a. 接收沙箱执行请求 (`scalebox.service.ts:104`)
ScaleboxService接收用户代码执行请求
```text
async execute(user: User, request: SandboxExecuteRequest): Promise<SandboxExecuteResponse>
```
### 1b. 通过队列执行 (`scalebox.service.ts:118`)
将执行任务加入队列进行异步处理
```text
const executionResult = await this.executeViaQueue(request.params, {
```
### 1c. 获取沙箱实例 (`scalebox.service.ts:100`)
从沙箱池中获取可用的沙箱包装器
```text
const wrapper = await this.sandboxPool.acquire(context);
```
### 1d. 执行代码 (`scalebox.service.ts:205`)
在沙箱中实际执行用户代码
```text
const executorOutput: ExecutorOutput = await wrapper.executeCode(params, {
```
### 2. 沙箱池管理和复用
沙箱实例的创建、复用和生命周期管理机制
### 2a. 尝试复用空闲沙箱 (`scalebox.pool.ts:58`)
从空闲队列中获取可复用的沙箱ID
```text
const sandboxId = await this.storage.popFromIdleQueue(this.templateName);
```
### 2b. 创建新沙箱 (`scalebox.pool.ts:74`)
当无空闲沙箱时创建新的沙箱实例
```text
return await this.wrapperFactory.create(context, this.sandboxTimeoutMs, onFailed);
```
### 2c. 保存沙箱元数据 (`scalebox.pool.ts:84`)
将沙箱状态信息持久化存储
```text
await this.storage.saveMetadata(wrapper);
```
### 2d. 归还到空闲队列 (`scalebox.pool.ts:109`)
执行完成后将沙箱放回池中供复用
```text
await this.storage.pushToIdleQueue(sandboxId, this.templateName);
```
### 3. Scalebox SDK集成
通过Scalebox SDK创建和连接沙箱实例的核心逻辑
### 3a. 创建Scalebox沙箱 (`base.ts:88`)
调用Scalebox SDK创建新的沙箱实例
```text
return guard(() => Sandbox.create(templateName, { apiKey, timeoutMs })).orThrow(
```
### 3b. 连接现有沙箱 (`base.ts:97`)
通过沙箱ID连接到已存在的沙箱实例
```text
return guard(() => Sandbox.connect(sandboxId, { apiKey })).orThrow(
```
### 3c. CodeBox适配器创建 (`codebox-adapter.ts:155`)
在sandbox-agent中创建code-interpreter类型的沙箱
```text
const sandbox = await Sandbox.create('code-interpreter', {
```
### 3d. 创建代码解释器 (`codebox-adapter.ts:174`)
基于沙箱创建CodeInterpreter实例用于代码执行
```text
this.codeInterpreter = new CodeInterpreter(this.sandbox, connectionConfig, api);
```
### 4. 多沙箱技术支持
Refly支持的多种沙箱技术及其集成方式
### 4a. Scalebox SDK集成 (`index.ts:15`)
主要沙箱技术Scalebox的SDK导入
```text
import { Sandbox, CodeInterpreter, type WriteInfo } from '@scalebox/sdk';
```
### 4b. Novita Sandbox加载 (`index.ts:30`)
动态加载Novita Sandbox模块作为备选方案
```text
const subModuleSpecifier = 'novita-sandbox/code-interpreter';
```
### 4c. API密钥配置 (`index.ts:132`)
设置Scalebox API密钥到环境变量
```text
process.env.SCALEBOX_API_KEY = apiKey ?? '';
```
### 4d. Novita API配置 (`index.ts:114`)
设置Novita Sandbox API密钥
```text
process.env.NOVITA_API_KEY = apiKey ?? '';
```
### 5. 代码执行和结果处理
在沙箱中执行代码并处理执行结果的完整流程
### 5a. 通过解释器执行 (`codebox-adapter.ts:417`)
使用CodeInterpreter在指定上下文中执行代码
```text
result = await this.codeInterpreter.execute({
```
### 5b. 直接沙箱执行 (`codebox-adapter.ts:426`)
回退到直接使用sandbox.runCode方法执行
```text
result = await this.sandbox.runCode(code, {
```
### 5c. 处理图像输出 (`codebox-adapter.ts:448`)
检测并处理代码生成的PNG图像输出
```text
if (result.png) {
```
### 5d. 上传生成文件 (`index.ts:881`)
将代码生成的文件上传到存储系统
```text
const uploaded = await this.params?.reflyService?.uploadBase64?.(this.params?.user, {
```
### 6. 沙箱配置和限制
沙箱的资源配置、超时设置和安全限制
### 6a. API密钥配置 (`.env.example:129`)
环境变量中的Scalebox API密钥设置
```text
SCALEBOX_API_KEY=
```
### 6b. 包装器类型 (`.env.example:132`)
选择使用executor或interpreter包装器
```text
SCALEBOX_WRAPPER_TYPE=interpreter
```
### 6c. 文件大小限制 (`scalebox.constants.ts:18`)
沙箱中单个文件的最大大小限制
```text
maxFileSize: 10 * 1024 * 1024, // 10MB
```
### 6d. 沙箱超时设置 (`scalebox.constants.ts:50`)
沙箱实例的默认超时时间
```text
SANDBOX_TIMEOUT_MS: 60 * 60 * 1000, // 1 hour
```